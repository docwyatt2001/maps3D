<!DOCTYPE HTML>
<html>
  <head>
    <style>
      body {
        margin: 0px;
        padding: 0px;
      }
    </style>
  </head>
  <body>
    <div id="container"></div>
    <script type="application/javascript" src="js/external/three/three.min.js"></script>
    
    <script type="application/javascript" src="js/external/three/controls/OrbitControls.js"></script>
    <script type="application/javascript" src="js/util/ImprovedNoise.js"></script>
    <!--
    <script type="application/javascript" src="js/external/three/controls/TrackballControls.js"></script>
  -->
    <script type="application/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>

    <script>
      var renderer, camera, scene, controls, profile;

      var worldWidth = 256;
      var worldDepth = 256;

      $(document).ready(init);

      function init(){
        // SET UP
        camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 20000 );
        scene = new THREE.Scene();
        renderer = new THREE.WebGLRenderer({ antialias: true });
        var container = $('#container');
        container.empty();
        container.append(renderer.domElement);
        controls = new THREE.OrbitControls( camera , renderer.domElement);

        // PROFILE
        var data = generateHeight(worldWidth, worldDepth);
        var geometry = new THREE.PlaneGeometry( 7500, 7500, worldWidth - 1, worldDepth - 1 );
        //geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );
        for ( var i = 0, l = geometry.vertices.length; i < l; i ++ ) {
          geometry.vertices[ i ].z = data[ i ] * 10;
        } 


        var texture = new THREE.Texture( generateTexture( data, worldWidth, worldDepth ), new THREE.UVMapping(), THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping );
        texture.needsUpdate = true;

        var profile1 = new THREE.Mesh( new THREE.PlaneGeometry(100, 100, 9,9), 
                                  new THREE.MeshBasicMaterial({map: texture}) 
                                  );
        var profile2 = new THREE.Mesh(new THREE.PlaneGeometry(100, 100, 9,9 ),
                                      new THREE.MeshLambertMaterial({color: 0x00ff00})
                                );

        profile = profile2;
        profile.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );
        profile.geometry.vertices[34].z = 10;
        profile.geometry.vertices[64].z = 10;
        profile.geometry.__dirtyVertices = true;
        //profile.geometry.__dirtyNormals = true;
        profile.geometry.computeCentroids();

        //profile.geometry.computeFaceNormals();
        //profile.geometry.computeVertexNormals();
        
        
        var plane = new THREE.Mesh( new THREE.PlaneGeometry(100, 100, 9,9 ),
                                  new THREE.MeshLambertMaterial({color: 0x00ff00})
                                );
        plane.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );
        generateHeights(plane);
        /*
        plane.geometry.vertices[34].z = 10;
        plane.geometry.vertices[64].z = 10;
        */
        plane.geometry.__dirtyVertices = true;
        //plane.geometry.__dirtyNormals = true;
        plane.geometry.computeCentroids();
        //plane.geometry.computeFaceNormals();
        //plane.geometry.computeVertexNormals();
        
        /*
        plane.shadowMapEnabled = true;
        plane.castShadow = true;
        plane.receiveShadow = true;
        */
        scene.add(plane);

        //generateHeights(profile);       
        profile.geometry.dynamic = true; 
        profile.receiveShadow = true;
        profile.castShadow = true;
        profile.shadowMapEnabled = true;
        profile.shadowMapSoft = true;

        //scene.add(profile);

        // CUBE
        var cube = new THREE.Mesh(new THREE.CubeGeometry(10, 10, 10, 1),
                                  new THREE.MeshLambertMaterial({color: 0xff0000, vertexColors: true})
                                );
        cube.position.set(0, 10, 0);
        cube.castShadow = true;
        scene.add(cube);

        //LIGHTING
        var ambientLight = new THREE.AmbientLight(0x666666);
        //scene.add(ambientLight);

        var directionalLight = new THREE.DirectionalLight(0xffffff, 4);
        directionalLight.position.set(170,40,0);
        directionalLight.target.position.copy(plane.position);
        directionalLight.castShadow = true;
        directionalLight.shadowCameraVisible = true;
        //scene.add(directionalLight);
        //scene.add( new THREE.DirectionalLightHelper(directionalLight, 2.5) );

        var spotLight = new THREE.SpotLight( 0xffffff, 4 );
        spotLight.position.set( 170, 40, 0 );
        /*
        spotLight.castShadow = true;
        spotLight.shadowDarkness = 100;        
        spotLight.shadowMapWidth = 1024;
        spotLight.shadowMapHeight = 1024;
        spotLight.shadowCameraNear = 5;
        spotLight.shadowCameraFar = 1024;
        //spotLight.shadowBias = 0.001;
        spotLight.shadowCameraFov = 70;
        spotLight.shadowCameraVisible = true;
        */
        scene.add( spotLight );

        var pointLight = new THREE.PointLight(0xffffff, 1);
        pointLight.position.set(70, 70, 0);
        //scene.add(pointLight);
        scene.add(new THREE.PointLightHelper(pointLight, 10));
        
        // CAMERA
        camera.position.set(80,80,80);
        camera.lookAt(profile.position);
        scene.add(camera);        

        // HELPERS
        scene.add(new THREE.AxisHelper(100));
        scene.add(new THREE.GridHelper(100,10));

        renderer.setSize(1000, 500)
        renderer.setClearColor(0x000000, 1)
        renderer.shadowMapEnabled = true;
        renderer.shadowMapSoft = true;
        renderer.shadowMapType = THREE.PCFSoftShadowMap;
        renderer.physicallyBasedShading = true;
        //renderer.render(scene, camera);
        animate();


      }

      function generateHeight( width, height ) {

        var size = width * height, data = new Float32Array( size ),
        perlin = new ImprovedNoise(), quality = 1, z = Math.random() * 100;

        for ( var i = 0; i < size; i ++ ) {

          data[ i ] = 0

        }

        for ( var j = 0; j < 4; j ++ ) {

          for ( var i = 0; i < size; i ++ ) {

            var x = i % width, y = ~~ ( i / width );
            data[ i ] += Math.abs( perlin.noise( x / quality, y / quality, z ) * quality * 1.75 );


          }

          quality *= 5;

        }

        return data;

      }

      function generateHeights(profile){
        for(var i=0;i<profile.geometry.vertices.length;i++){
            profile.geometry.vertices[i].z += Math.floor(Math.random() * 20);
        }
      }

      function generateTexture( data, width, height ) {

        var canvas, canvasScaled, context, image, imageData, level, diff, vector3, sun, shade;

        vector3 = new THREE.Vector3( 0, 0, 0 );

        sun = new THREE.Vector3( 1, 1, 1 );
        sun.normalize();

        canvas = document.createElement( 'canvas' );
        canvas.width = width;
        canvas.height = height;

        context = canvas.getContext( '2d' );
        context.fillStyle = '#000';
        context.fillRect( 0, 0, width, height );

        image = context.getImageData( 0, 0, canvas.width, canvas.height );
        imageData = image.data;

        for ( var i = 0, j = 0, l = imageData.length; i < l; i += 4, j ++ ) {

          vector3.x = data[ j - 2 ] - data[ j + 2 ];
          vector3.y = 2;
          vector3.z = data[ j - width * 2 ] - data[ j + width * 2 ];
          vector3.normalize();

          shade = vector3.dot( sun );

          imageData[ i ] = ( 96 + shade * 128 ) * ( 0.5 + data[ j ] * 0.007 );
          imageData[ i + 1 ] = ( 32 + shade * 96 ) * ( 0.5 + data[ j ] * 0.007 );
          imageData[ i + 2 ] = ( shade * 96 ) * ( 0.5 + data[ j ] * 0.007 );
        }

        context.putImageData( image, 0, 0 );

        // Scaled 4x

        canvasScaled = document.createElement( 'canvas' );
        canvasScaled.width = width * 4;
        canvasScaled.height = height * 4;

        context = canvasScaled.getContext( '2d' );
        context.scale( 4, 4 );
        context.drawImage( canvas, 0, 0 );

        image = context.getImageData( 0, 0, canvasScaled.width, canvasScaled.height );
        imageData = image.data;

        for ( var i = 0, l = imageData.length; i < l; i += 4 ) {

          var v = ~~ ( Math.random() * 5 );

          imageData[ i ] += v;
          imageData[ i + 1 ] += v;
          imageData[ i + 2 ] += v;

        }

        context.putImageData( image, 0, 0 );

        return canvasScaled;

      }


      /**
      * Einzelnes Frame rendern
      */
      function animate(){
        requestAnimationFrame(animate)
        renderer.render( scene, camera );
        controls.update();
      }      


    </script>
  </body>

  
</html>